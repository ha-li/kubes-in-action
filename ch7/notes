This chapter is about configmap volumes and secret volumes

topics of review
-specifying arguments to pass config options to container using command line arguments 
-using env variables as a way to config container
-using configmap volumes

Overriding Docker default commands and arguments
-----------------------------------------------
In a Dockerfile, the two instructions in ENTRYPOINT and CMD serve very specific purpose:
 ENTRYPOINT - defines the executabble invoked when the container is started
 CMD - the arguments to pass to ENTRYPOINT

although you can use CMD to specify the full command and argument to execute, the 
correct way is through ENTRYPOINT, and only specify CMD if you want to define the
default arguments.

Then the image can be run without any arguments: 
 > docker run <image>   ( this will trigger ENTRYPOINT )

To specify arguments:
 > docker run <image> <arguments>  (this will pass <arguments> as CMD to ENTRYPOINT)

ENTRYPOINT supports two forms:
-  shell form ENTRYPOINT node app.js
-  exec form ENTRYPOINT ["node", "app.js"]


to build haja/fortune:args:
 docker build -t docker.io/haja/fortune:args .
to push it to docker hubb
 docker push docker.io/haja/fortune:args

to run the image locally:
 docker run -it docker.io/haja/fortune:args


To see the contents of the file generated on the docker image:
 docker exec <container_id> more /etc/htdocs/index.html

you should see a new file generated every 10 secs (from ch6) and x secs from this chapter 


If you are building a kubernetes pod, you can choose to override the container ENTRYPOINT and
CMD. To do that, in the spec:

apiVersion: v1
kind: Pod
spec:
  containers:
  - image: some/image
    command: ["/bin/command"]
    args: ["arg1", "arg2", "arg3"]
...

-most of the time you will only set the args and rarely will you override the command.
-once the command and args are set, they cannot be updated after the pod is created


So using the above, we can create a pod spec that overrides a CMD argument:

> vi fortune-override-args.yaml
apiVersion: v1
kind: Pod
metadata:
  name: fortune-override
spec:
  containers:
  - image: haja/fortune:args
    args: ["2"]                    <---- this is an override of content from ch6
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    emptyDir: {}

the changes above means 2 is the arg to fortune:args, which means the loop runs every 2 secs
and generates a new /var/htdocs/index.html every 2 secs, vs in ch6, it was always 10 secs

In this example, there was only 1 argument to pass. If you have multiple arguments, you can use
the list notation:

...
spec:
  containers:
  - image: haja/fortune:args
    args: 
    - foo
    - bar
    - "15"
    name: html-generator
...

to see the kubernetes pod spec for overriding default arguments see contents of fortune-args

Specifying Environment Variables in a Container Definition
----------------------------------------------------------
you can pass environment variables to a container in the pod spec:
-there is not an option to define a pod env variable and have all containers in the pod inherit it
-the environment variable is defined at the container level using the pod spec.
-if you want each container to have the same value, you need to specify in each container

apiVersion: v1
kind: Pod
metadata: 
  name: fortune-env
spec:
  containers:
  - image: haja/fortune:env
    env:
    - name: INTERVAL
      value: "30"
    name: html-generator
...

see contents of fortune-env for the kubernetes pod spec and the docker container.


If you need to reuse the value of a previously set env variable:

    env:
    - name: FIRST_VAR
      value: "foo"
    - name: SECOND_VAR
      value: "$(FIRST_VAR)bar"


Drawbacks of harding coding environment variables
-------------------------------------------------
Hard coding environment variables in a pod spec means to need separate pod spec for your
production and development pods. You want to reuse the same pod spec, but have different
configuration values in different environments.

This is where ConfigMap resources comes into play.



Using ConfigMap to Decouple Configuration
-----------------------------------------
You want to be able to decouple config options that varying in different environments separate
from the source code. Your pod descriptor is really source code for your application, so
you want really want the configurations outside of your pod description.

ConfigMaps
----------
ConfigMaps are objects that hold key/value pairs. The values can be short literals
to full config files

Applications doesn't need to read the config map directly, or even know that it exists.
The contents of the config map are passed to containers either as environment variables or
as files in a volume.
- if the content is referenced as a command line arg, then you can use the notation $(ENV_VAR)
  like done in the args example above
-if the content of the config map is referenced as a file in a volume, then you can treat it as
 so (below)

Having the config in a separate stand-alone obbject like this allows you to keep multiple
manifests for configMaps with the same name. Pods reference the configMap by name.


Creating a ConfigMap
--------------------
There are two ways to create a config map
 - kubectl create configmap with simple values
 - kubectl create configmap from files stored in disk
       1) with yaml descriptors
       2) with conf files
       3)

 both are created using: 
     kubectl create configmap ...

 (ConfigMap keys must be valid DNS subdomain names (alpha-numeric, dashes, underscores + dots. They
  can start with leading dot)

Simple Values
-------------
the simplest way to create a configmap is by using the kubectl create command:

 > kubectl create configmap fortune-config-literal --from-literal=sleep-interval=25

   this will create a config map called fortune-config that will hold one value:
      sleep-interval : 25

   to see this config map, 
 > kubectl get configmap fortune-config-literal -o yaml
    and you wil get back its yaml descriptor

 apiVersion: v1
 data: 
    sleep-interval: "25"
 kind: ConfigMap
 metadata:
     creationTimestamp: 2019-01-13T19:56:59Z
     name: simple-config-literal
     namespace: default
     resourceVersion: "84354"
     selfLInk: /api/v1/namespace/default/configmaps/fortune-config
     uid: 6370a19c-176d-11e9-9d69-080027551fc7
 

 You can also create multiple literals at the same time under one config map

 > kubectl create configmap multi-config-literal --from-literal=foo=bar --from-literal=bar=bax --from-literal=one=two
   this will create a config map called simple-config with 3 values:
      foo : bar
      bar : bax
      one : two

 you can see the yaml descriptors for these two config maps using kubectl get configmap:

 > kubectl get configmap multi-config-literal -o yaml

 apiVersion: v1
 data:
   bar: baz
   foo: bar
   one: two
 kind: ConfigMap
 metadata:
   creationTimestamp: 2019-01-13T19:58:47Z
   name: multi-config-literal
   namespace: default
   resourceVersion: "576007"
   selfLink: /api/v1/namespaces/default/configmaps/myconfigmap
   uid: a380b3fe-176d-11e9-9d69-080027551fc7

 
   
 You can also create configmaps using the kubectl create command with a yaml descriptor file
 > kubectl create -f fortune2-config.yaml
   
   (the only data required in the metadata section is name:)
apiVersion: v1
data:
   ninja: haja
   orange: new-black
   grey: rain
kind: ConfigMap
metadata:
   name: fortune2-config


The name of the configmap is what you'll be referencing the config map by.

 Then to see the config map content:
 > kubectl get configmap fortune2-config -o yaml

-----------------

ConfigMaps can be used to store coarse-grained config data, such as complete config files.
The best way to do so is to use the kubectl create command to read in a file from disk
and store them as individual entries in the config map.

 To create config maps with config files:

 > kubectl create configmap test-config --from-file=test.conf

 kubernetes will look for test.conf in the current directory, and store the contents of
 test.conf in a config map with the file name as the map key (or you can specify a
 key manually)

 To see the contents of this config map:

 > kubectl get configmap test-config -o yaml
apiVersion: v1
data:
  test.conf: |+
    hi: bye
    no: yes

kind: ConfigMap
metadata:
  creationTimestamp: 2019-01-13T20:19:34Z
  name: test-config
  namespace: default
  resourceVersion: "577556"
  selfLink: /api/v1/namespaces/default/configmaps/test-config
  uid: 8aab002d-1770-11e9-9d69-080027551fc7


 To create config map from json file:
-------------------------------------
 > kubectl create configmap test-json-config --from-file=test-json.json
 
 kubernetes will look for test-json.json from the current directory, and store the contents
 of test-json.json into a config map with the file name as the map key

 To see the contents of this config map

 > kubectl get configmap test-json-config -o yaml
 apiVersion: v1
data:
  test-json.json: |
    {
       day: "1"
       fun: 2
    }
kind: ConfigMap
metadata:
  creationTimestamp: 2019-01-13T20:22:41Z
  name: test-json-config
  namespace: default
  resourceVersion: "577790"
  selfLink: /api/v1/namespaces/default/configmaps/test-json-config
  uid: fa2018ca-1770-11e9-9d69-080027551fc7


Adding a custom key
-------------------
 > kubectl create configmap my-config --from-file=customekey=my.json

 > kubectl get configmap my-config -o yaml
apiVersion: v1
data:
  customkey: |
    {
      a: b
      c: d
    }
kind: ConfigMap
metadata:
  creationTimestamp: 2019-01-13T21:38:04Z
  name: my-config
  namespace: default
  resourceVersion: "578958"
  selfLink: /api/v1/namespaces/default/configmaps/my-config
  uid: 81f7c280-177b-11e9-9d69-080027551fc7


Using path directory as source of configs
-----------------------------------------
To create a confim map with individual map entry for all files in a specific directory, use
the --from-file=/path/to/dir

> kubectl create configmap all-config --from-file=.

 this will create config maps of all the files in the current directory with the file names
 as the map keys (any files that are valid subdomain names -- including swp files, etc).

> kubectl get configmap all-config -o yaml 
  will show all the config maps from all the files in .

Combining options
-----------------
You can combine the various options into one command

> kubectl create configmap all-my-config 
  1  --from-file=foo.json
  2  --from-file=bar=foobar.conf
  3  --from-file=/config-opts/
  4  --from-literal=some=thing

 1 - is single file config with the file name as map name
 2 - is single file with specified map name
 3 - is from whole directory
 4 - is a literal value

eg:
> kubectl create configmap uni-config --from-file=test.conf --from-file=unikey=test.conf --from-literal=test=dee

> kubectl get configmap all-my-config -o yaml
apiVersion: v1
data:
  test: dee
  test.conf: |+
    hi: bye
    no: yes

  unikey: |+
    hi: bye
    no: yes

kind: ConfigMap
metadata:
  creationTimestamp: 2019-01-13T22:10:51Z
  name: uni-config
  namespace: default
  resourceVersion: "580237"
  selfLink: /api/v1/namespaces/default/configmaps/uni-config
  uid: 16e31d99-1780-11e9-9d69-080027551fc7



Using the values from a config map
----------------------------------
There are 3 ways to get the values from the map inside a pod's container.
- 1 or more environment variables
- use a configmap volume to expose configmap entries as files

(
- setting an single environment variable with the value of a configmap's key
- exposing all the entries in a config map as environment variables (kubernetes 1.6)
- passing configmap values as a command line argument
- configmap volume to expose configmap entries as files
)

Exposing configmap entries as environment variables
---------------------------------------------------

To use the values from the map in your pod container, in your yaml descriptor:

apiVersion: v1
kind: Pod
metadata:
   name: fortune-config
spec:
   containers:
   - image: haja/fortune:env
     env:
     - name: INTERVAL              <--------1
       valueFrom:                  <--------2
         configMapKeyRef:          <--------2
           name: fortune-config    <--------3
           key: sleep-interval     <--------4

1 - the environment variable to populate in the container
2 - the construct that tells kubernetes the value is coming from a configMap value
3 - the configmap name
4 - the key inside the configmap

This will set the environment variable INTERVAL with a value from the config map fortune-config 
with key "sleep-interval"

(If the container using the config map is created and the config map is not yet started, when the pod
is created, the container will not start (other containers not referencing the config map will jstart just 
fine, but the container with the broken config map reference will not start).
If you then create the missing config map, the failed container will start not requiring the pod be 
recreated.

Optionally, you can set configMapKeyRef.optional: true, in which case, the container will
still start even if the config map does not exist)


ConfigMaps are an excellent way of decoupling the configuration from the pod specification, allowing
you to keep all the configuration options close together instead of having them
splattered around the pod definition or duplicated across multiple pod manifests.

If the environment variable is an invalid name, kubernetes will skip the conversion.
So if the environment variable name is CONFIG_FOO-BAR, this will not work.

Exposing all the environment variables using the envFrom option:
----------------------------------------------------------------
When your configmap contains many values, setting the individual environment variables 
using the valueFrom construct is error prone and tedious.

Instead you can expose all the entries of a config map as environment variables
using the "envFrom" construct.


...
spec:
  containers:
  - image: some-image
    envFrom:                 <-------1
    - prefix: CONFIG_        <-------2
      configMapRef:          <-------3
         name: my-config-map <-------4

1 - the construct that tells kubernetes to expose all the keys from the configmap as env variables
2 - the prefix to prepend to all the env variables -- this construct is optional
3 - the kubernetes construct that tells the config map reference
4 - config map to expose

This spec will expose all the values from my-config-map as environment variables, prefixed with: CONFIG_
The prefix is optional, if it is not specfied, it will just export the keys from the configMap with no
prefix.

So if this configmap my-config-map has 3 keys (FOO, BAR, FOO-BAR), then the 
resulting environment variables will bbe CONFIG_FOO, CONFIG_BAR.
FOO-BAR is not a valid env variable name, so it will not be created (see above section)


Passing a configMap entry as a command line argument
----------------------------------------------------
From the above section, we know how to expose a configmap value as a env variable.
Once we have the value as a env variable, we are able to reference it and pass it
as command line arguments to processes in the container

To pass the value from a configMap as an argument to the main process running in the container:

apiVersion: v1
kind: Pod
metadata:
   name: fortune-args-from-configmap
spec:
  containers:
  - image: haja/fortune:args
    env:                            <-----------1
    - name: INTERVAL                <-----------2
      valueFrom:                    <-----------3
        configMapKeyRef:            <-----------3
          name: fortune-config      <-----------4
          key: sleep-interval       <-----------5
    args: ["$(INTERVAL)"]           <-----------6

1 - the kubernetes construct that says to map a configmap key to env variable
2 - the env variable name
3 - the kubernetes construct that says the value is coming from a config map key single value
4 - the configmap name
5 - the config map key
6 - re-using the env variable as a command line argument to the container

env: -name: INTERVAL will define an environment variable INTERVAL
args: ["$(INTERVAL)"] will use the defiend env variable as argument to the container process


ConfigMap volume to expose ConfigMap entries as files
-----------------------------------------------------
ConfigMap can also contain whole config files.
You can then expose the whole file to the container using a special volume, a configMap volume.

-configMap volume will expose each entry of the configMap as a file, the process running
in the container can obtain the entry's value by reading the contents of the file

-this is the ideal way to pass large config files to the container

In this example, we will configure an nginx app server to compress responses it sends to clients.
Nginx reads its configurations in from a config file.

first create a directory "nginx-conf" for holding all your config files, 
in nginx-conf will be 2 files, my-nginx-config.conf and sleep-interval

 my-nginx-config.conf will be:

server {
  listen       80;
  server_name  www.kubia-example.com;

  gzip on;
  gzip_types text/plain application/xml;

  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
  }
}

In the above nginx config settings, the gzip tells to turn on gzip in responses, 
and the type of mime to set the response as.

sleep-interval will be:

25

create a config map called fortune-config from this directory

> kubectl create configmap fortune-config --from-file=nginx-conf
configmap/fortune-config created

To see the contents of this configmap:
> kubectl get configmap fortune-config -o yaml
apiVersion: v1
data:
  my-nginx-config.conf: "server {\n  listen       80;\n  server_name  www.kubia-example.com;\n\n
    \ gzip on;\n  gzip_types text/plain application/xml; \n \n  location / {\n    root
    \  /usr/share/nginx/html;\n    index  index.html index.htm;\n  }\n}\n"
  sleep-interval: |
    25
kind: ConfigMap
metadata:
  creationTimestamp: 2019-01-13T23:01:29Z
  name: fortune-config
  namespace: default
  resourceVersion: "584004"
  selfLink: /api/v1/namespaces/default/configmaps/fortune-config
  uid: 2975392f-1787-11e9-9d69-080027551fc7


You should see the two entries, the first holds the content of my-nginx-config.conf
and the 2nd holds the contents of sleep-interval
 
The | char after the colon means that a literal multi-line value follows.
 

To create a volume populated with teh contents of a ConfigMap:
-create a volume that references the configMap by name, 
-mount the volume in a container
-initialize the volume with files created from a configMap entry

(the following is condensed of fortune-pod-configmap-volume.yaml in git)
apiVersion: v1
kind: Pod
metadata:
  name: fortune-configmap-volume
spec:
  containers:
  - image: nginx:latest
    name: web-server
    volumeMounts:
    ...
    - name: config              <------ 1
      mountPath: /etc/nginx/conf.d
      readOnly: true
    ...
  volumes:
  ...
  - name: config                <-------2
    configMap:                  <-------2
      name: fortune-config      <-------2
  ...

This spec 2) defines a volume named config that is a configMap named fortune-config
and 1) references 2), mounting it at mountPath /etc/nginx/conf.d so that nginx automatically uses it

To create the pod with the specified containers:
> kubectl create -f fortune-pod-configmap-volume.yaml

this creates a pod called fortune-configmap-volume.

To set port forwarding on this pod:
> kubectl port-forward fortune-configmap-volume 8080:80 &

Then to hit the container with the gzip header:
> curl -H "Accept-Encoding: gzip" -I localhost:8080

You should see the response:
HTTP/1.1 200 OK
Server: nginx/1.15.8
Date: Tue, 15 Jan 2019 05:24:55 GMT
Content-Type: text/html
Last-Modified: Tue, 15 Jan 2019 05:24:54 GMT
Connection: keep-alive
ETag: W/"5c3d6ea6-36"
Content-Encoding: gzip

In the response header we see the content has been encoded with gzip, so we know nginx
used the configurations we specified in the config map which we exposed in the configmap volume.

After running the container, if you look in /etc/ngxin/conf.d you should see
my-nginx-config.conf
sleep-interval

Since you don't really want sleep-interval as a file, and you are going to pass it in as a 
env variable, you really want to populate a configMap volume with only part of the configMap's
entries:

(see fortune-pod-configmap-volume-with-item.yaml)

  ...
  volumes:
  - name: config
    configMap:
      name: fortune-config
      items:                            <-----1
      - key: my-nginx-config.conf       <-----2
        path: gzip.conf                 <-----3

1 using items: will select the entries to include in the volume
2 selects the entry specified by key
3 the name of the file you want it to be called on the configmap volume (gzip.conf)

> kubectl create -f fortune-pod-configmap-volume-with-items.yaml

to see the single file
> kubectl exec fortune-configmap-volume-with-item -c web-server ls /etc/nginx/conf.d/
gzip.conf



Mounting a volume as a directory will hide any files in the original /etc/nginx/conf.d
which is okay if that is what you want, but you can also just mount a file into a directory

(fortune-pod-configmap-volume-with-item-subpath.yaml)

> kubectl create -f fortune-pod-configmap-volume-with-item-subpath.yaml
...
spec:
  containers:
  - image: some/image
    volumeMounts: 
    - name: myvolume
      mountPath: /etc/someconfig.conf   <-----1
      subPath: myconfig.conf            <-----2

1 This is the file name you want to be your configmap volume file to be mounted as.
2 This is the entry on the configMap you want to mount 

So in your configMap myvolume, there will be a key called myconfig.conf, the contents of that
file will be mounted as a file /etc/someconfig.conf on your /etc directory, without hiding any other files



By default, all files in a configMap volume are 644 (-rw-r-r--).
To change that:

...
volumes:
- name: config
  configMap:
    name: fortune-config
    defaultMode: "6600"    <-----1

1 will change the files to -rw-rw----

To see the file modes
> kubectl exec fortune-configmap-volume-default-mode -c web-server -- ls -l /etc/nginx/conf.d

Updating App config without restarting
--------------------------------------
when you use an environment variable or command line arg, you have to restart the container
to pick up changes

configmap changes exposed as a volume allows you to update the config without having to 
recreate the pod or even restart the container
-when you update a configmap, all the files in the volume referencing it are updated,
 the process then needs to detect they've been changed and reload them

> kubectl edit configmap fortune-config

After a while, the configmap is updated, as well as the file in the configmap volume.
You can confirm this on the file
> kubectl exec fortune-configmap-volume -c web-server cat /etc/nginx/conf.d/my-nginx-config.conf

Now ngxin needs to be reloaded from the config file
 > kubectl exec fortune-configmap-volume -c web-server -- nginx -s reload



configmap volume files are softlinks

Secrets
--------
secrets are like config maps except that they hold secret information
-secrets can be passed to the container as environment variable or 
- expose secret entries as files in a volume

secrets are only distributed to nodes that run the pods that need access to the Secret volume
-secrets are stored in memory, preventing the need to wipe the disk after 


Secrets are kubernetes resources, so you can list them using:
> kubectl get secrets
NAME                  TYPE                                  DATA      AGE
default-token-rwmk9   kubernetes.io/service-account-token   3         106d
tls-secret            kubernetes.io/tls                     2         83d

You can get detailed information on a secret by:
> kubectl describe secrets

Name:         default-token-rwmk9
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name=default
              kubernetes.io/service-account.uid=af0379f7-c526-11e8-80cb-080027551fc7

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1066 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tcndtazkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImFmMDM3OWY3LWM1MjYtMTFlOC04MGNiLTA4MDAyNzU1MWZjNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.ayXitGfLE9Fje-EAvrJKXdfGTz_TT_gpPe7Sy5oeosYQI-vEQLybtgUAZ_YfGa0xh04Eb4OVoEdFCqKsBjhyq5J7aOY5N4z7cqknLlU5cczL5i2y1C4tc4BKEDlZrnE3nOpCmXAnTQXU_D0mbD_QbJR_wotq3y2xqg6zHnioCYP2QA__q5qasg1cXruGVUQXNjVOXWdaDhY4BCdG_OYEZeCp2p6bSAOVzuAV48GvEKE_w1JCtIXBYmTtuQadVblfAEuYDA3DZ26r5aOoi917tCmL16o3naoNZSRlSFlkTf-1j8-DDpXjWTxLNks-xfWJPzU4UryWSum21bHEx6lCBQ


Name:         tls-secret
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  kubernetes.io/tls

Data
====
tls.crt:  997 bytes
tls.key:  1679 bytes


Every container is mounted the default-token secret

You can see where the default secret token is mounted by 
> kubectl describe pods
...
    Mounts:
      /usr/share/nginx/html from html (ro)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-rwmk9 (ro)

...

  So the secrets volume is mounted at /var/run/secrets/kubernetes.io/serviceaccount

Since secrets are just configmap volumes, we can ls that on our pods
> kubectl exec mypod -- ls /var/run/secrets/kubernetes.io/serviceaccount/
ca.crt
namespace
token

Creating Secrets
----------------
secrets are just configmap base64 encoded

To create secrets, first we need to create a special configmap called secrets

> echo foo > bar
> echo secret1 > ca.cert
> echo secret2 > tls.cert
> kubectl create secret generic fortune-https-secret --from-file=bar --from-file=ca.cert --from-file=tls.cert


To see the contents of the secrets config map
> kubectl get secret fortune-https-secret -o yaml
apiVersion: v1
data:
  foo: YmFyCg==
  ca.cert: LASDFiadfhwuejasf ... 
  tls.cert: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRV ... 
kind: Secret
metadata:
  creationTimestamp: 2019-01-15T07:21:09Z
  name: fortune-https-secret
  namespace: default
  resourceVersion: "632583"
  selfLink: /api/v1/namespaces/default/secrets/fortune-https-secret
  uid: 212e26cb-1896-11e9-9d69-080027551fc7
type: Opaque


When viewing secret config maps, they will be base64 encoded. 
Why are secrets base64 encoded?
Secrets can be binary, which base64 will convert binary values into plain-text.

But when you view the contents of the file mounted on the volume, they are 
the same as the original (not base64 encoded)

Here is the contents of foo, which in the config map, was encoded, but in the volume mount:
> kubectl exec nginx-boom-with-secrets -- more /usr/my/secrets/foo
bar

It is not encoded, which means your application can use the secret files as they are (no decoding
necessary, which should make sense)

Secrets are limited to 1 MB.
-------------------

To use a secret volume, in your pod spec:

apiVersion: v1
kind: Pod
metadata:
  name: fortune-https
spec:
  containers:
    - image: haja/fortune:env
      name: html-generator
      volumeMounts:
      - name: html
        mountPath: /var/htdocs
    - image: nginx:alpine
      name: web-server
      volumeMounts:
      - name: html
        mountPath: /usr/share/nginx/html
        readOnly: true
      - name: config
        mountPath: /etc/nginx/conf.d
        readOnly: true
      - name: certs
        mountPath: /etc/nginx/certs/
        readOnly: true
      ports: 
      - containerPort: 80
      - containerPort: 443
    volumes:
    - name: html
      emptyDir: {}
    - name: config
      configMap:
        name: fortune-config
        items:
        - key: my-nginx-config.conf
          path: https.conf
    - name: certs
      secrets:
        secretName: fortune-https-secret 

Here we have declared a secret volume (certs) that gets its contents from the secrets configmap fortune-https-secret.
The secret volume handle certs is used as the alias that gets referenced in the volume mounts,
which also configures that secret volumes mount point, as well as its readOnly properties.

Other ways to create a secret
-----------------------------
Keep in mind that a secret configmap is a resource, so we should be able to declare it like any other resource:

apiVersion: v1
kind: Secret
metadata:
  name: ninja-secret
stringData:
  ninja: i am a ninja
data:
  tls.cert: LsOtlja2VisLtlyJyaHFURSLKtka18nbjax...

If the tls.cert is a valid base64 encoded string, then we can create this like any other resource
> kubectl create -f ninja-secrets.yaml

We can view the secret resources
> kubectl get secrets
NAME                  TYPE                                  DATA      AGE
default-token-rwmk9   kubernetes.io/service-account-token   3         107d
fortune-https         Opaque                                4         22h
secret-nginx          Opaque                                2         1h
tls-secret            kubernetes.io/tls                     2         84d
ninja-secret          Opaque                                2         4s

We can get the contents of the secrets
> kubectl get secrets ninja-secret -o yaml
apiVersion: v1
data:
  https.cert: MIICvDCCAaQCCQCHqd+QlxmpGDANBgkqhkiG9w0BAQsFADAgMR4wHAYDVQQDDBV3d3cua3ViaWEtZXhhbXBsZS5jb20wHhcNMTkwMTE1MDcyMDI0WhcNMjkwMTEyMDcyMDI0WjAgMR4wHAYDVQQDDBV3d3cua3ViaWEtZXhhbXBsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDVUtK8jtjPF+qA51fxoMDPJWJ1LYB/Nd3t3DfSmC9aZ8ywhITfFUA2thZREdNbedWHNPKFU3ViJh2hjT5udQNS8t4FL2C9qZSSBrrtMfNEDsrX2P/iQTm53Wrfp7B+CngI1KU22/7D0EHq2MWOh3WeldS50JbPkD2Bp9fzZK7r5O3G03OPLqsvl2Ra+9po+lwuGLeunbVm3V9BizvHN9g1VJyvsBK9JYg+Qf0g4oxoBMbYjTemMrtDiQpWaLt/kqN/tjwlJGHLpae11uiNIZ/cMqfnMcmITHmREczudwxxKmPORWIfzeTzlvLKzM/4SNPP4PHslrCdQNeT/RnqXUq9AgMBAAEwDQYJKoZIhvcNAQELBQADggEBAGPmpg9Li1RQIPj5o0mzHWa9mF3E9Vo5GPI8L1bndjM19c3MQ4772g1WJSo8jWu5irRrTd1Z/aIwLY18oDgMEvsd+ZIYaUf/KB+fs+aWau8CYdCTM9kCiFNaEWOZiVYVcP5X0fCwH8lC7ioYSqZ6ojaI9aaz/ogBMXq0B7Z5nQIGgiShVoFNnEw8JyY5Ech28Ii7HGaEz74JPrIGbPnVURvXi5oCmqPr3NFvf6oE+kw1Xa+quQIJLmr2Ol50t8Bcdr7RUUQ0T9nf+xuBzbm7huFkMEpjjaubSy+1oF2VMkNbcgyawLn+14hl94rGIBC1kue9yd+f1A4QdXXQNQVOmYE=
  ninja: bmluamFQYXNzd29yZA==
kind: Secret
metadata:
  creationTimestamp: 2019-01-16T06:13:44Z
  name: ninja-secret
  namespace: default
  resourceVersion: "646733"
  selfLink: /api/v1/namespaces/default/secrets/ninja-secret
  uid: e109feb0-1955-11e9-9d69-080027551fc7
type: Opaque


Note that both the stringData and the certs are base64 encoded even though the spec is not.
Thats because the secrets config map will always return it base64 encoded.


Secret volumes are always mounted as in memory, so that you do not have to worry about deleting 
the contents, so you should be able to see that:
> kubectl exec nginx-boom-with-secrets -c web-server -- mount | grep secrets
tmpfs on /usr/my/secrets type tmpfs (ro,relatime)
tmpfs on /run/secrets/kubernetes.io/serviceaccount type tmpfs (ro,relatime)

tmpfs is an in memory temporary fs, which confirms that


