Deployments
-----------

-replacing pods with new pods
-updating managed pods

kubernetes helps you move towards a zero down time application updating process
-this can be done with replication sets and replication controllers, but
 a deployment resource can also be added that sits onto of a replication set/controller
 that allows you to update applications declaratively


There are two main ways to update applications running in pods
-you tear down all the old pods and then start up the new pods
-start up the new pods, and once they are up, tear down the old ones,
 either by adding all the new pods at once, then deleting all the 
 old pods at once, or adding new pods sequentially while removing
 old pods one at a time

Each method as its advantages and disadvantages
-if you tear down all at once and then deploy, there is a small down time
 but it requires the least amount of resources
-the second option there is always a service up, so there is no gap, but
 it requires up to double the required resources, and may not always be
 possible if you have an underlying eg database change that is not
 supported in an old resource

Kubernetes aids in both forms of deployment.
-if you are downing a tear down before spinning up again, you can modify
 your replication set template so that it refers to v2 instead of v1.
 the replication controller will then notice no pods match its label
 selector and will then spin up the new instances

-if you are doing a blue-green deployment where you bring up a new set
 of pods with a different label (v2), and then switch over the Service
 selector from v1 to v2, before deleting the old replication set
 (to change the Service selector use kubectl set selector command)
-you can also do something similar but scaling down step wise while
 scaling up step wise, in which case, you will have the Service selector
 include both the old and new pods. Doing this manually is laborious, 
 Kubernetes allows you to do this with one command.

Rolling Updates with Replication Controllers
--------------------------------------------
You can create a manifest with multiple resources bundled in it.
Just put all the specs into one file, each resource must be separated
by a line with 3 dashes (---)

In this excersice, we will create a Replication and LoadBalancer Service
(see kubia-rc-and-service-v1.yaml).

 > kubectl create -f kubia-rc-and-service-v1.yaml

To do a rolling update, you will use the command 
 > kubectl rolling-update <old-rc> <new-rc> --image=<new image>
 > kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2

This will do a scale up of kubia-v2 while scaling down v1. Kubernetes 
will copy the spec from v1, replace the image, and change the label 
selector, as well as add a new label "deployment". In fact kubernetes
has modified both the replication controller as well as the service
so that the deployment label matches. 

To see it:
 > kubectl describe rc kubia-v2

Once the proper labels have been added to the replication controller
and the service, the replication controller on the old image
is scaled down by 1 while the new replication controller is scaled up 
by 1. 

Then the scale step is repeated. Until the old is 0 and the new is fully
up.


There are some negatives about this process of scaling up and down:
-kubernetes modified your labels on the rc and service, which is 
 unexpected behavior
-kubectl client is the one sending requests to the master api server.
 what happens if you lose network connection during the update, 
 then pods and replication controllers would end up in an intermediate
 state. 
-the kubectl commands mean that it is a imperative, but most of 
 kubernetes is declarative

These negatives lead to the development of Deployment Resources

Deployments for Declarative App Updates
---------------------------------------
The spec for a Deployment Resource 
 see kubia-deployment.yaml

Deployment is a higher level resource meant for deploying applications
and updating them declaratively, rather than through a rc or rs, which 
are lower level concepts.

A Deployment will create its own ReplicaSet underneath, which it will
then manage as part of the deployment process. During the deployment
process the RS will actually do the creation of new pods and then
manage them.

The role of the Deployment resource during the update process is to 
create another RS, and then coordinate the scale up and down of
the pods.













